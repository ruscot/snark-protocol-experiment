\subsection{COCO}
\label{sec:COCO}
\cite{coco} is designed to prove that someone else knows a knowledge. Where the knowledge is already knows by you. And it's supposed to provide a high level of snark circuit implementation, to be more user friendly. The repository \href{https://github.com/akosba/jsnark}{jsnark} implement their idea and give some examples. By the way to achieve this they cipher the witness inside the circuit in order to put a backdoor. With that if someone knows the witness it can prove it. And this encryption is interesting in our case. 

For example with an RSA encryption the essential challenge is that the arithmetic operations are over integers mod n, where n is larger than the SNARK field of order p. They represent integers mod n as $\ceil{\frac{\log_2 n}{m}}$ m-bit elements. To multiply a pair of such integers z=xy mod n, they construct a circuit that verifies xy = qn + z, where q and z are $\ceil{\frac{\log_2 n}{m}}$ m-bit elements provided as witnesses by the prover. Their current implementation for big integers uses m = 64.

But as they said it's not efficient enough so they proposed a Diffie-Hellman key exchange via a SNARK-friendly field extension. Instead of relying on RSA as the main PKE scheme, they investigate another scheme based on the \textbf{Discrete-Logarithm} (DL) problem in Extension Fields, and use it for symmetric key exchange. Since p is only 254-bit prime, the DL problem in $F_p$ will not be hard, therefore an extension $F_{p^\mu }$ will be used instead. The key exchange circuit has two generators in that case g, h $\leftarrow F_{p^\mu}$ , where $\langle g\rangle$ = $\langle h \rangle$ is a large multiplicative subgroup of order $q|{p^\mu} -1 $. They follow Lentraâ€™s guidelines for selecting q to be a factor of the $\mu$-th cyclotomic polynomial $\theta_\mu$(x) when evaluated at x = p  \cite{lenstra_guide}.